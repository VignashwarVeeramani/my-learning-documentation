# Controller Layer: Annotations

This document details the annotations used in the `AccountsController` class, which is responsible for handling all incoming REST API requests for the Accounts microservice.

## 1. Class-Level Annotations

These annotations are applied to the `AccountsController` class itself, defining its overall behavior.

### `@Tag`
This annotation is from the OpenAPI (Swagger) library and is used to group related API endpoints in the generated documentation.

*   **`name`**: A short name for the group of APIs.
*   **`description`**: A brief explanation of what the APIs in this group do.

**Sample Code:**
```java
@Tag(
    name = "CRUD REST APIs for Accounts in EazyBank",
    description = "CRUD REST APIs in EazyBank to CREATE, UPDATE, FETCH AND DELETE account details"
)
@RestController
// ...
public class AccountsController {
    // ...
}
```

### `@RestController`
A convenience annotation that combines `@Controller` and `@ResponseBody`. It marks the class as a web request handler and ensures that the return value of every method is automatically serialized into the HTTP response body (usually as JSON).

**Sample Code:**
```java
@RestController
@RequestMapping(path="/api", produces = {MediaType.APPLICATION_JSON_VALUE})
public class AccountsController {
    // ...
}
```

### `@RequestMapping`
This annotation is used to map web requests to the entire class.

*   **`path`**: Defines the base URL path for all endpoints within this controller (e.g., `/api`).
*   **`produces`**: Specifies the media type that the controller's methods will produce, in this case, `application/json`.

**Sample Code:**
```java
@RestController
@RequestMapping(path="/api", produces = {MediaType.APPLICATION_JSON_VALUE})
public class AccountsController {
    // ...
}
```

### `@AllArgsConstructor`
This is a Lombok annotation that automatically generates a constructor with a parameter for every field in the class. This is used here for dependency injection of the `IAccountsService`.

**Sample Code:**
```java
@AllArgsConstructor
public class AccountsController {
    private IAccountsService iAccountsService;
    // Constructor is auto-generated by Lombok
}
```

### `@Validated`
This annotation, part of Spring Framework, is used to enable validation for method parameters annotated with constraint annotations (like `@Pattern`). It ensures that incoming request parameters are validated before the method body is executed.

**Sample Code:**
```java
@RestController
@Validated
public class AccountsController {
    // ...
}
```

## 2. Method-Level Annotations

These annotations are applied to the individual methods inside the controller.

### `@Operation`, `@ApiResponses`, `@ApiResponse`
These OpenAPI (Swagger) annotations are used to describe a specific API endpoint.

*   **`@Operation`**: Provides a summary and description for a single API operation.
*   **`@ApiResponses`**: A container for multiple `@ApiResponse` annotations.
*   **`@ApiResponse`**: Describes a single possible response from the API, including the HTTP status code and a description. It can also define the schema of the response body, especially for error cases.

**Sample Code:**
```java
@Operation(
    summary = "Create Account REST API",
    description = "REST API to create new Customer &  Account inside EazyBank"
)
@ApiResponses({
    @ApiResponse(
        responseCode = "201",
        description = "HTTP Status CREATED"
    ),
    @ApiResponse(
        responseCode = "500",
        description = "HTTP Status Internal Server Error",
        content = @Content(
            schema = @Schema(implementation = ErrorResponseDto.class)
        )
    )
})
@PostMapping("/create")
public ResponseEntity<ResponseDto> createAccount(@Valid @RequestBody CustomerDto customerDto) {
    // ...
}
```

### `@PostMapping`, `@GetMapping`, `@PutMapping`, `@DeleteMapping`
These are shortcut annotations for `@RequestMapping` that map HTTP requests to handler methods based on the HTTP method.

*   **`@PostMapping("/create")`**: Maps HTTP POST requests to the `/api/create` path.
*   **`@GetMapping("/fetch")`**: Maps HTTP GET requests to the `/api/fetch` path.
*   **`@PutMapping("/update")`**: Maps HTTP PUT requests to the `/api/update` path.
*   **`@DeleteMapping("/delete")`**: Maps HTTP DELETE requests to the `/api/delete` path.

**Sample Code:**
```java
@PostMapping("/create")
public ResponseEntity<ResponseDto> createAccount(/*...*/) { /*...*/ }

@GetMapping("/fetch")
public ResponseEntity<CustomerDto> fetchAccountDetails(/*...*/) { /*...*/ }

@PutMapping("/update")
public ResponseEntity<ResponseDto> updateAccountDetails(/*...*/) { /*...*/ }

@DeleteMapping("/delete")
public ResponseEntity<ResponseDto> deleteAccountDetails(/*...*/) { /*...*/ }
```

## 3. Parameter-Level Annotations

These annotations are applied to the parameters of the controller methods.

### `@RequestBody`
This annotation indicates that a method parameter should be bound to the body of the HTTP request. Spring Boot automatically deserializes the incoming JSON into the specified Java object (`CustomerDto`).

**Sample Code:**
```java
@PostMapping("/create")
public ResponseEntity<ResponseDto> createAccount(@RequestBody CustomerDto customerDto) {
    // ...
}
```

### `@Valid`
This annotation, part of the Jakarta Bean Validation API, triggers the validation of the annotated object. When used with `@RequestBody`, it ensures that the incoming `CustomerDto` object passes the validation rules defined within the `CustomerDto` class itself (e.g., `@NotEmpty`, `@Email`).

**Sample Code:**
```java
@PostMapping("/create")
public ResponseEntity<ResponseDto> createAccount(@Valid @RequestBody CustomerDto customerDto) {
    // ...
}
```

### `@RequestParam`
This annotation binds a method parameter to a URL query parameter. It's used here to get the `mobileNumber` from requests like `/api/fetch?mobileNumber=1234567890`.

**Sample Code:**
```java
@GetMapping("/fetch")
public ResponseEntity<CustomerDto> fetchAccountDetails(@RequestParam String mobileNumber) {
    // ...
}
```

### `@Pattern`
This Jakarta Bean Validation annotation is used to constrain a string parameter. It checks if the value matches the specified regular expression.

*   **`regexp`**: The regular expression to match against.
*   **`message`**: The error message to return if the validation fails.

**Sample Code:**
```java
@GetMapping("/fetch")
public ResponseEntity<CustomerDto> fetchAccountDetails(
    @RequestParam @Pattern(regexp="(^$|[0-9]{10})", message = "Mobile number must be 10 digits") String mobileNumber
) {
    // ...
}
```